..TCP通讯案例(C-S）..
1.Server：
	1).简介：用于服务器端，接收所有链接的服务器的Client的’处理‘部门
	2).基构：一个main方法，运行一条监听线程，每监听到一个客户端开启一个线程，创建一个单例模式管理器管理所有的线程socket会话
	3).思想：面向对象和分层协作
	4).分层：只专注于特定的事情，面向对象思想来解耦
		a.程序的入口，使用main方法，只负责调用一个业务主程序，引发执行
		b.业务主程序，只需一条线程类，只负责写出多线程，多线程下的虚拟单程序对象调用，同时此刻声明单程序放到多线程的管理器中进行管理
		c.虚拟单程序，只负责一个单程序下的实例，这是一个线程类
		d.多线程管理，这个类管理器很关键，他的设计方式确定，其它虚拟单程序在多线程下的异步并发情况，和生命周期：
			A.这个类是一个单例类，所以构造器要返回一个static final的自己对象的实例
			B.这个类中实例的数组或集合对象，就是多线程下的单例对象（在一个内存运行中）
			C.在此类中创建方法，关联类中的对象，就能实现多线程下管理器的作用，即：多线程下的共享中心（交互地带）
			D.此类中创建的方法一般只给虚拟单程序调用
			E.管理多个虚拟单程序对象的集合数组，建议使用vector，当虚拟单程序引用对象为null时，管理器将不再管理	
	5).分层对接：应对分层之后的对接思想
		a.程序入口只需要运行一次业务主程序
		b.业务主程序只需要运行虚拟单程序对象线程和创建多线程管理对象单例对象，同时负责将它们俩交互起来
		c.虚拟单程序中会使用到多线程管理实例，所以虚拟单程序调用多线程管理中的方法实现向其它虚拟单线程交换信息
		d.多线程管理需要管理所有创建的虚拟单程序的对象实例，通过这些对象实例，可以在单例模式的多线程管理中实现信息的交换
	6).总结：多线程应用，分层须清晰（多多练习，实践经验）
	
2.Client：
	1).简介：用于客户端，对应于服务器中虚拟单程序配合的第三方‘发送’个体
	2).基构：一个main方法运行一个加工的安全线程，线程内创建一个窗体对象实例，再创建一个单程序运行实例
	3).思想：面向对象和分层协作
	4).分层：只专注于特定的事情，面向对象思想来解耦
		a.程序的入口，main方法运行一个安全线程，安全线程只负责运行窗体对象，和单程序实例对象
		b.业务主程序，由客户端窗体取代创建，一种窗体化循环线程对象，每组件都是这个线程的其中监听线程
		c.单程序实例，非线程类，但是在这里获取每一个上面窗体实例对象，对应的衔接起来而只负责窗体小功能的实现
	5).分层对接：应对分层之后的对接思想
		a.程序入口只需要运行一次安全线程
		b.安全线程只需要运行窗体线程和创建单程序实例，同时负责将它们交互起来
		c.窗体对象线程只需要创建窗体线程和单程序实例的调用，单程序只需要引入此次实例化的窗体对象，对其业务方法的实现，供窗体调用
	6).总结：客户端窗体应用，多多实践
3.API:
	1).socket(ip,port):创建一个套接字，相当于邮轮运输码头上的那个’集装箱子’，是信息的载体
	2).serverSocket(port):服务器开启一个socket的监听端口，相当于码头上接货的主管人员
	3).socket.get…(stream):是从套接字中获得的信息流对象，是’集装箱子‘里的‘货物’
	4).serversocket.accpet:一个阻塞方法，相当于码头接货主管人员所做的事情，即：来了游轮就卸货
4.C-S：
	1).S更为核心，从server的基构可以简单全面认识交互的准确性，C比较抽象，但是从server的观点看过来是一致的
	2).继承Jframe，创建实例，即是调用单线程循环监听实例，可以通过写一段代码验证‘线程的对象引用为null时线程结束’，答案是否
